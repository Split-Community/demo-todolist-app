import type { ReportOpts } from 'web-vitals'

/**
 * Type of a property value
 * @typedef {string | number | boolean | null} PropertyType
 */
type PropertyType = string | number | boolean | null;
/**
 * Event properties should be an object with values of type string, number, boolean or null.
 * @typedef {Object.<number, string, boolean, null>} Properties
 */
export type Properties = {
  [propertyName: string]: PropertyType,
};

export type EventData = {
  eventTypeId: string,
  value?: number,
  properties?: Properties,
};

export type ConsentStatus = 'GRANTED' | 'DECLINED' | 'UNKNOWN';

/**
 * A function that receives the RUM Agent's `track` method to send events to Split.
 *
 * It can optionally return an object with a `flush` method, which will be called by the RUM Agent when to page is hidden or terminated (See https://developer.chrome.com/articles/page-lifecycle-api/#states).
 * This is useful to `track` any pending events before the page is closed, but consider that it might be called multiple times.
 *
 * @typedef {function} EventCollector
 * @param {Object} ctx - An object with the RUM Agent's `track` method.
 * @returns {void | { flush: function(): void }} Optionally, an object with a `flush` method.
 * @example
 * ```js
 * function myEventCollector({ track }) {
 *   track({ eventTypeId: 'my.event' });
 *
 *   return {
 *     flush() {
 *       track({ eventTypeId: 'my.event' });
 *     }
 *   }
 * };
 *
 * SplitRumAgent.register(myEventCollector);
 * ```
 */
export type EventCollector = (ctx: {
  track(event: EventData): boolean
}) => void | {
  flush(): void
};

/**
 * A pair of user key and it's trafficType, required for tracking events.
 * @typedef {Object} Identity
 * @property {string} key The user key.
 * @property {string} trafficType The key traffic type.
 */
export type Identity = {
  key: string;
  trafficType: string;
};

/**
 * The Split RUM Agent configuration object
 */
export type SplitRumAgentConfig = {
  /**
   * Optional prefix to append to the `eventTypeId` of the events sent to Split.
   *
   * For example, if you set the prefix to 'my-app', the event type 'error' will be sent as 'my-app.error'.
   *
   * @property {string} prefix
   * @default ''
   */
  prefix?: string,
  /**
   * Base URL where the agent will post events.
   * @property {string} url
   * @default 'https://events.split.io/api'
   */
  url?: string,
  /**
   * The agent posts the queued events data in bulks. This parameter controls the posting rate in seconds.
   * @property {number} pushRate
   * @default 30
   */
  pushRate?: number,
  /**
   * The maximum number of event items we want to queue. If we queue more values, events will be dropped until they are sent to Split.
   * @property {number} queueSize
   * @default 5000
   */
  queueSize?: number,
  /**
   * User consent status. Possible values are `'GRANTED'`, which is the default, `'DECLINED'` or `'UNKNOWN'`.
   * - `'GRANTED'`: the user grants consent for tracking events. The agent sends them to Split cloud.
   * - `'DECLINED'`: the user declines consent for tracking events. The agent does not send them to Split cloud.
   * - `'UNKNOWN'`: the user neither grants nor declines consent for tracking events. The agent tracks them in its internal queue, and eventually either sends
   * them or not if the consent status is updated to 'GRANTED' or 'DECLINED' respectively. The status can be updated at any time with the `setUserConsent` method.
   *
   * @typedef {string} userConsent
   * @default 'GRANTED'
   */
  userConsent?: ConsentStatus
};

export interface ILogger {
  debug(msg: string): void
  info(msg: string): void
  warn(msg: string): void
  error(msg: string): void
}

export type SplitRumAgentSettings = {
  i: Array<Identity>,
  a: string | false,
  p: Properties,
  log: ILogger
} & Required<SplitRumAgentConfig>;

/**
 * The Split's Browser RUM Agent object
 */
export declare const SplitRumAgent: {
  /**
   * Configures the Browser RUM Agent.
   *
   * @function setup
   * @param {string} sdkKey - The client-side SDK key of your Split environment.
   * @param {SplitRumAgentConfig=} config - Configuration options.
   */
  setup(sdkKey: string, config?: SplitRumAgentConfig): typeof SplitRumAgent;
  /**
   * Adds the identities to associate the events with. At least 1 identity must be set to send events to Split.
   *
   * @function addIdentities
   * @param {Array<Identity>} identities - An array of identities.
   */
  addIdentities(identities: Identity[]): void;
  /**
   * Adds an identity to associate the events with. At least 1 identity must be set to send events to Split.
   *
   * @function addIdentity
   * @param {Identity} identity - An identity object.
   */
  addIdentity(identity: Identity): void;
  /**
   * Removes all identities.
   *
   * @function removeIdentities
   */
  removeIdentities(): void;
  /**
   * Removes a given identity.
   *
   * @function removeIdentity
   * @param {Identity} identity - An identity object to remove.
   */
  removeIdentity(identity: Identity): void;
  /**
   * Retrieves all identities
   *
   * @function getIdentities
   * @returns {Array<Identity>} The stored identities.
   */
  getIdentities(): Identity[];
  /**
   * Returns the RUM Agent configuration.
   *
   * It is exposed for internal usage only, not considered part of the public API, and might be renamed or removed eventually.
   *
   * @function __getConfig
   *
   * @TODO remove from type definitions or replace with a `settings` property.
   */
  __getConfig(): SplitRumAgentSettings;
  /**
   * Registers an event collector.
   *
   * @function register
   * @param {EventCollector} eventCollector - The event collector function.
   */
  register(eventCollector: EventCollector): typeof SplitRumAgent;
  /**
   * Tracks a custom `error` type event.
   *
   * Shortcut for `SplitRumAgent.track('error', undefined, { message: error.message || error, stack: error.stack })`.
   *
   * @function trackError
   * @param {string | Error} error - The error message or Error object to track.
   * @returns {boolean} Whether the error event was tracked or not. The event will not be tracked if it is an invalid type (e.g., undefined), user consent is 'DECLINED' or the internal events queue is full and couldn't be flushed.
   */
  trackError(error: string | Error): boolean;
  /**
   * Tracks a custom event.
   *
   * @function track
   * @param {string} eventTypeId - The event type corresponding to this event.
   * @param {number=} value - The value of this event.
   * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.
   * @returns {boolean} Whether the event was tracked or not. The event will not be tracked if it has invalid types (e.g., eventTypeId is not a string), user consent is 'DECLINED', or the internal events queue is full and couldn't be flushed.
   */
  track(eventTypeId: string, value?: number, properties?: Properties): boolean;
  /**
   * Tracks a custom event.
   *
   * @function track
   * @param {EventData} event - The event object.
   * @returns {boolean} Whether the event was tracked or not. The event will not be tracked if it has invalid types (e.g., eventTypeId property is not a string), user consent is 'DECLINED', or the internal events queue is full and couldn't be flushed.
   */
  track(event: EventData): boolean;
  /**
   * Sets properties to append to events.
   *
   * @function setProperties
   * @param {Properties} properties - The properties to be appended to events, an object mapping property names to values.
   */
  setProperties(properties: Properties): void;
  /**
   * Returns the properties that are appended to events.
   *
   * @function getProperties
   * @returns {Properties} The properties that are appended to events.
   */
  getProperties(): Properties;
  /**
   * Removes all properties that are appended to events.
   *
   * @function removeProperties
   */
  removeProperties(): void;
  /**
   * Updates the user consent status. Possible values are `true` and `false`, which represent user consent `'GRANTED'` and `'DECLINED'` respectively.
   * - `true ('GRANTED')`: the user has granted consent for tracking events. The agent will send them to Split cloud.
   * - `false ('DECLINED')`: the user has declined consent for tracking events. The agent will not send them to Split cloud.
   *
   * @function setUserConsent
   * @param {boolean} userConsent The user consent status, true for 'GRANTED' and false for 'DECLINED'.
   * @returns {boolean} Whether the provided param is a valid value (i.e., a boolean value) or not.
   */
  setUserConsent(userConsent: boolean): boolean;
  /**
   * Gets the user consent status.
   *
   * @function getUserConsent
   * @returns {ConsentStatus} The user consent status.
   */
  getUserConsent(): ConsentStatus;
};

declare global {
  interface Window {
    SplitRumAgent: typeof SplitRumAgent;
  }
}

/**
 * Collects Time-to-Interactive metric, using the tti-polyfill package (https://www.npmjs.com/package/tti-polyfill).
 * This is a pluggable event collector, only available when using the RUM Agent library from NPM.
 *
 * Collected event format:
 * ```
 * {
 *   eventTypeId: 'time.to.interactive',
 *   value: number,
 * }
 * ```
 *
 * How to use:
 * - Import `tti` function and register it to the RUM Agent:
 * ```
 * import { SplitRumAgent, tti } from '@splitsoftware/rum-agent';
 *
 * SplitRumAgent.register(tti);
 * ```
 * - Add the following snippet of code to the head of your document (before any other scripts run):
 * ```
 * <script>
 *   !function(){if('PerformanceLongTaskTiming' in window){var g=window.__tti={e:[]};
 *   g.o=new PerformanceObserver(function(l){g.e=g.e.concat(l.getEntries())});
 *   g.o.observe({entryTypes:['longtask']})}}();
 * </script>
 * ```
 */
export declare function tti(): EventCollector;

export interface IRouteChange {
  fromUrl: string,
  toUrl: string,
  historyChangeSource: 'pushState' | 'replaceState' | 'popstate'
}

export interface IRouteChangesOptions {
  filter?: (routeChange: IRouteChange) => boolean
}

/**
 * Collects route changes events (a.k.a client-side routing or in-page navigation), for Single Page Applications.
 * Route changes correspond to the action of changing the URL and displaying a new view within the page, without a page reload.
 *
 * Collected event format:
 * ```
 * {
 *   eventTypeId: 'route.change',
 *   value: number | undefined, // properties.duration
 *   properties: {
 *     // URL value before the change, without the origin (protocol, host and port)
 *     fromUrl: string,
 *     // URL value after the change, without the origin (protocol, host and port)
 *     toUrl: string,
 *     // Type of URL change
 *     // * `pushState` indicates a new entry added to the history stack, when `history.pushState` is called
 *     // * `replaceState` indicates the entry at the current index in the history stack being replaced, when `history.replaceState` is called
 *     // * `popstate` indicates a change to an arbitrary index in the history stack
 *     historyChangeSource: 'pushState' | 'replaceState' | 'popstate',
 *
 *     // Browsers that support the Performance Timeline API will include the following properties:
 *     // Estimated duration of the navigation transition in milliseconds. The calculation is based on a time window of long tasks and resources around the history change event.
 *     duration?: number,
 *     // Value of performance.now() when the navigation started
 *     startTime?: number,
 *     // Time spent on the previous route (`fromUrl`) in milliseconds
 *     timeOnRoute?: number,
 *   }
 * }
 * ```
 */
export declare function routeChanges(options?: IRouteChangesOptions): EventCollector;

export interface IWebVitalsOptions {
  reportOptions?: {
    onCLS?: boolean | ReportOpts,
    onFCP?: boolean | ReportOpts,
    onFID?: boolean | ReportOpts,
    onINP?: boolean | ReportOpts,
    onLCP?: boolean | ReportOpts,
    onTTFB?: boolean | ReportOpts,
  }
}

/**
 * Collects Web-Vitals metrics (https://www.npmjs.com/package/web-vitals).
 *
 * By default it collects all web-vitals metrics, but you can specify which ones to collect by passing a `reportOptions` object.
 *
 * For example:
 * ```
 * SplitRumAgent.register(webVitals({
 *   reportOptions: {
 *     // collects only the core web-vitals
 *     onCLS: true,
 *     onFID: true,
 *     onLCP: true,
 *     // other web-vital metrics are not collected
 *   }
 * }));
 * ```
 *
 * Collected event format:
 * ```
 * {
 *   eventTypeId: 'webvitals.cls' | 'webvitals.fcp' | 'webvitals.fid' | 'webvitals.inp' | 'webvitals.lcp' | 'webvitals.ttfb',
 *   value: number,
 *   properties: {
 *     rating: 'good' | 'needsImprovement' | 'poor',
 *     navigationType: 'navigate' | 'reload' | 'back_forward' | 'back-forward-cache' | 'prerender' | 'restore'
 *   }
 * }
 * ```
 *
 * @param {IWebVitalsOptions} options
 * @default
 * ```
 * { reportOptions: { onCLS: true, onFCP: true, onFID: true, onINP: true, onLCP: true, onTTFB: true } }
 * ```
 */
export declare function webVitals(options?: IWebVitalsOptions): EventCollector;
