"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fallbackPost = exports.post = exports.sendEvents = void 0;
var assign_1 = require("./assign");
var context_1 = require("./context");
// Key and trafficType are pieces of data we'll add here because:
// a) not having those should not prevent queueing,
// b) we may have multiple tt/key tuples, may be easier to handle here.
function sendEvents(events, useBeacon) {
    var config = window.SplitRumAgent.__getConfig();
    var eventsWithIdentity = [];
    for (var i = 0; i < events.length; i++) {
        var event_1 = events[i];
        (0, assign_1.assignIdentities)(event_1, config.i, eventsWithIdentity);
    }
    if (eventsWithIdentity.length) {
        return post(config.url + '/events/beacon', {
            entries: eventsWithIdentity,
            token: config.a,
            sdk: context_1.languageVersion
        }, useBeacon);
    }
    return false;
}
exports.sendEvents = sendEvents;
// Post data to our BE. Exporting only for UT purposes.
function post(url, data, useBeacon) {
    var stringifiedData = JSON.stringify(data);
    useBeacon = useBeacon // check we don't avoid on purpose
        && typeof navigator === 'object' && navigator.sendBeacon; // and that it exists
    return useBeacon ?
        navigator.sendBeacon(url, stringifiedData) :
        fallbackPost(url, stringifiedData);
}
exports.post = post;
// Fetch and XHR request fallback. Exporting only for UT purposes.
function fallbackPost(url, payload) {
    if (typeof fetch === 'function') {
        fetch(url, {
            method: 'POST',
            body: payload,
            headers: {
                'Content-Type': 'text/plain;charset=UTF-8'
            }
        }).catch(function () {
            // noop
        });
    }
    else {
        try {
            var req = new XMLHttpRequest();
            req.open('POST', url, true);
            req.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8');
            req.send(payload);
        }
        catch (e) {
            return false;
        }
    }
    return true; // This is a fallback so it's mostly fire and forget.
}
exports.fallbackPost = fallbackPost;
