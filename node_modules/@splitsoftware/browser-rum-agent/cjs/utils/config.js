"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SplitRumAgent = void 0;
var queue_1 = require("./queue");
var isArray_1 = require("./isArray");
var isBoolean_1 = require("./isBoolean");
var isObject_1 = require("./isObject");
var isString_1 = require("./isString");
var log_1 = require("./log");
var whenLoaded_1 = require("./whenLoaded");
var assign_1 = require("./assign");
var validateIdentity_1 = require("./validateIdentity");
var constants_1 = require("./constants");
// Built-in event collectors
var errors_1 = require("../metrics/errors");
var navigation_1 = require("../metrics/navigation");
var validateEvent_1 = require("./validateEvent");
// Browser support:
// - ES5 syntax
// - assumes availability of `window.addEventListener` and `document.location`, which are broadly supported.
// - feature detection of Promise, History and Performance APIs is done by event collector modules. These features are required for some modules to collect data, but not for the RUM Agent to work.
// In Browser, we pollute the global `window` object with the agent.
// In NodeJS, we only export it and no event collectors are registered.
var isBrowser = typeof window === 'object' && typeof document === 'object';
var globalRef = isBrowser ? window : {};
(function (w, isBrowser) {
    if (w.SplitRumAgent)
        return;
    var _config = {
        i: [],
        a: false,
        p: {},
        prefix: '',
        url: 'https://events.split.io/api',
        pushRate: 30,
        queueSize: 5000,
        log: log_1.log,
        userConsent: constants_1.CONSENT_GRANTED // User consent is assumed to be granted by default
    };
    var _isConfigured = false;
    function calculateAndFlush() {
        if (isBrowser && !_isConfigured && _config.a && _config.i.length) {
            _isConfigured = true;
            // always async never inasync ;)
            setTimeout(queue_1.flush, 0);
        }
    }
    var collectors = [];
    // SplitRumAgent would be our namespace
    var SplitRumAgent = {
        // Initialization params
        setup: function (sdkKey, config) {
            if ((0, isObject_1.isObject)(config)) {
                (0, assign_1.objectAssign)(_config, config);
            }
            if ((0, isString_1.isString)(sdkKey)) {
                _config.a = sdkKey;
                calculateAndFlush();
            }
            else {
                _config.log.error('SDK key must be a string.');
            }
            // allow for chaining.
            return SplitRumAgent;
        },
        // Configure identities
        addIdentities: function (identities) {
            if ((0, isArray_1.isArray)(identities)) {
                identities.forEach(function (identity) { return SplitRumAgent.addIdentity(identity); });
            }
            else {
                _config.log.error('Identities must be an array of objects with key and trafficType.');
            }
        },
        addIdentity: function (identity) {
            var validatedIdentity = (0, validateIdentity_1.validateIdentity)(identity, _config.log);
            if (validatedIdentity && !_config.i.some(function (i) { return (0, validateIdentity_1.areEqual)(i, validatedIdentity); })) {
                _config.i.push(validatedIdentity);
                calculateAndFlush();
            }
        },
        removeIdentities: function () {
            _config.i = [];
        },
        removeIdentity: function (identity) {
            var validatedIdentity = (0, validateIdentity_1.validateIdentity)(identity, _config.log);
            if (validatedIdentity) {
                _config.i = _config.i.filter(function (i) { return !(0, validateIdentity_1.areEqual)(i, validatedIdentity); });
            }
        },
        getIdentities: function () {
            return _config.i;
        },
        // Custom error handler.
        trackError: function (e) {
            return (0, errors_1.handleCustomErrors)(e, SplitRumAgent);
        },
        // Track custom events.
        track: queue_1.track,
        // register event collector
        register: function (eventCollector) {
            if (typeof eventCollector !== 'function') {
                _config.log.error('register method must be called with an event collector function.');
            }
            else {
                collectors.push(eventCollector(SplitRumAgent));
            }
            // allow for chaining.
            return SplitRumAgent;
        },
        // Custom properties
        setProperties: function (properties) {
            (0, assign_1.objectAssign)(_config.p, (0, validateEvent_1.validateProperties)(properties, _config.log));
        },
        getProperties: function () {
            return _config.p;
        },
        removeProperties: function () {
            _config.p = {};
        },
        // User consent
        setUserConsent: function (userConsent) {
            if (!(0, isBoolean_1.isBoolean)(userConsent)) {
                _config.log.warn('setUserConsent: provided param must be a boolean value');
                return false;
            }
            _config.userConsent = userConsent ? constants_1.CONSENT_GRANTED : constants_1.CONSENT_DECLINED;
            return true;
        },
        getUserConsent: function () {
            return _config.userConsent;
        },
        // Private members for internal use only.
        // @TODO review how to expose config
        __getConfig: function () {
            return _config;
        },
        __queue: queue_1.queue,
    };
    if (isBrowser) {
        // Built-in collectors
        SplitRumAgent.register(navigation_1.onNavigationTimingMetrics);
        SplitRumAgent.register(errors_1.onError);
        // Post events periodically
        (0, whenLoaded_1.whenLoaded)(queue_1.setSchedule);
        // If there's a pagehide or visibilitychange event, calculate what's possible and send events using beacon by default
        (0, whenLoaded_1.onPageHideOrVisibilityChange)(function () {
            collectors.forEach(function (collector) {
                if (collector && typeof collector.flush === 'function')
                    collector.flush();
            });
            (0, queue_1.flush)(true);
        });
    }
    w.SplitRumAgent = SplitRumAgent;
})(globalRef, isBrowser);
exports.SplitRumAgent = globalRef.SplitRumAgent;
