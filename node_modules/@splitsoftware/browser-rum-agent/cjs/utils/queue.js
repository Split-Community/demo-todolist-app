"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.track = exports.setSchedule = exports.flush = exports.queue = void 0;
var context_1 = require("./context");
var transport_1 = require("./transport");
var isObject_1 = require("./isObject");
var assign_1 = require("./assign");
var constants_1 = require("./constants");
var validateEvent_1 = require("./validateEvent");
// How to detect we are configured? Static = may be present by now
//                                  Delayed = that would be the trigger but need to notify here.
// We could start it from a different spot calling setSchedule;
// We'll treat it as a FIFO queue
// Size/batch limitations => TODO only if necessary.
exports.queue = [];
// @TODO: Apply batching if needed
/**
 * Flush the queue of events.
 *
 * @param useBeacon - Whether to use navigator.sendBeacon or not. Defaults to false.
 * @returns true if events were sent, or a falsy value otherwise (e.g., queue is empty, config is not ready, or there was an error sending events)
 */
function flush(useBeacon) {
    var conf = window.SplitRumAgent.__getConfig();
    // Only send events if we do have the config.
    if (conf.a && conf.i.length && conf.userConsent === constants_1.CONSENT_GRANTED) {
        var toSend = exports.queue.splice(0, exports.queue.length);
        return toSend.length && (0, transport_1.sendEvents)(toSend, useBeacon);
    }
}
exports.flush = flush;
function setSchedule() {
    setInterval(flush, window.SplitRumAgent.__getConfig().pushRate * 1000);
    flush(); // Attempt a flush when setting the schedule, like a first tick.
}
exports.setSchedule = setSchedule;
function track(eventTypeId, value, properties) {
    var conf = window.SplitRumAgent.__getConfig();
    var eventData = (0, validateEvent_1.validateEvent)((0, isObject_1.isObject)(eventTypeId) ?
        eventTypeId : {
        eventTypeId: eventTypeId,
        value: value,
        properties: properties
    }, conf.log);
    // If the event is invalid or the user consent is DECLINED, drop the event.
    if (!eventData || conf.userConsent === constants_1.CONSENT_DECLINED)
        return false;
    // If people configures the agent at a really late time, prevent having a giant queue and attempt to send them or drop. First events will be the most important ones anyways.
    if (exports.queue.length >= conf.queueSize) {
        if (!flush()) {
            conf.log.warn('Dropping event due to queue size limit.');
            return false;
        }
    }
    // @ts-expect-error adding timestamp to event
    eventData.timestamp = Date.now(); // <-- This is not the most accurate but it shouldn't really matter much. The error margin should be small. We can actually calculate the timestamp later.
    if (conf.prefix)
        eventData.eventTypeId = conf.prefix + "." + eventData.eventTypeId;
    // include extra properties
    var commonProperties = {
        connectionType: (0, context_1.getConnectionType)(),
        url: (0, context_1.getUrl)(),
        userAgent: context_1.userAgent
    };
    // merge common properties with custom and event properties
    eventData.properties = (0, assign_1.objectAssign)(commonProperties, conf.p, (0, isObject_1.isObject)(eventData.properties) ? eventData.properties : {});
    // @ts-expect-error not part of the public API
    if (window.SplitRumAgent.onEvent)
        eventData = window.SplitRumAgent.onEvent(eventData);
    if (eventData)
        (0, assign_1.assignIdentities)(eventData, window.SplitRumAgent.__getConfig().i, exports.queue);
    return true;
}
exports.track = track;
