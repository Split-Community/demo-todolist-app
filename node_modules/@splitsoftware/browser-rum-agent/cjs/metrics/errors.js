"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onError = exports.handleCustomErrors = void 0;
var getErrorData_1 = require("../utils/getErrorData");
var constants_1 = require("../utils/constants");
/**
 * Add error into queue
 */
function trackError(error, ctx) {
    var errorData = (0, getErrorData_1.getErrorData)(error);
    return errorData ?
        ctx.track({
            eventTypeId: 'error',
            value: null,
            properties: {
                message: errorData.message,
                stack: errorData.stack,
            }
        }) :
        false;
}
/**
 * Handle custom error. Here we handle whatever the customer want to send. Ideally
 * we expect a string or an error object.
 */
function handleCustomErrors(e, ctx) {
    return trackError(e ? e : constants_1.UNAVAILABLE, ctx);
}
exports.handleCustomErrors = handleCustomErrors;
/**
 * Captures uncaught errors and promise rejections.
 *
 * @TODO: sync snippet in HTML head to not miss events if loaded asynchronously.
 */
function onError(ctx) {
    function handleUncaughtErrors(event) {
        trackError(event ? event.error || event.message || constants_1.UNAVAILABLE : constants_1.UNAVAILABLE, ctx);
    }
    function handleRejectionsErrors(e) {
        trackError(e ? e.reason : constants_1.UNAVAILABLE, ctx);
    }
    // In case customer placed the snippet in the head, remove listeners and process errors
    var w = window; // @ts-expect-error object might be polluted
    var g = w.__error;
    if (g) {
        w.removeEventListener('error', g.l1);
        w.removeEventListener('unhandledrejection', g.l2);
        // @TODO remove `setTimeout` eventually. ATM we have to run next code asynchronously, because `track` calls require global SplitRumAgent available
        setTimeout(function () {
            g.e1.forEach(handleUncaughtErrors);
            g.e2.forEach(handleRejectionsErrors); // @ts-expect-error object might be polluted
            delete w.__error;
        }, 0);
    }
    // Capture browser uncaught errors.
    w.addEventListener('error', handleUncaughtErrors);
    // Capture browser promise rejection errors.
    w.addEventListener('unhandledrejection', handleRejectionsErrors);
}
exports.onError = onError;
