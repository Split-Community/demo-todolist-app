"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onRouteChangeTiming = void 0;
var assign_1 = require("../../utils/assign");
var log_1 = require("../../utils/log");
var onRouteChange_1 = require("./onRouteChange");
var performanceEntries_1 = require("./performanceEntries");
var DEFAULT_QUIET_WINDOW_MILLIS = 50; // 50ms
var DEFAULT_WAIT_WINDOW_MILLIS = 5000; // 5s
var ROUTE_CHANGE_ENTRY_NAME = 'routeChange';
/**
 * Captures SPA route changes, calculates their duration, and calls the `callback` function each time a route change is detected.
 * @param callback function to call when a route change is detected
 *
 * ```
 * RouteChangeEntry = {
 *   // URL value before the change
 *   fromUrl: string,
 *   // URL value after the change
 *   toUrl: string,
 *   // Type of URL change
 *   // * `pushState` indicates a new entry added to the history stack, by calling `history.pushState`
 *   // * `replaceState` indicates the entry at the current index in the history stack being replaced, by calling `history.replaceState`
 *   // * `popstate` indicates a change to an arbitrary index in the history stack (by calling `history.back`, `history.forward` or `history.back` mehotds, or manually clicking the back or forward buttons in the browser)
 *   //    or a navigation using location properties and methods (https://html.spec.whatwg.org/multipage/nav-history-apis.html#the-location-interface). It corresponds to a `popstate` history event.
 *   historyChangeSource: 'pushState' | 'replaceState' | 'popstate',
 *
 *   // Browsers that support the Performance Timeline API will include the following properties:
 *   // Estimated duration of the navigation transition, in milliseconds. The calculation is based on a time window of long tasks and resources around the history change event.
 *   duration: number,
 *   // Value of performance.now() when the navigation started
 *   startTime: number,
 *   // Time spent on the previous route (`fromUrl`), in milliseconds
 *   timeOnRoute: number,
 * }
 * ```
 */
function onRouteChangeTiming(callback, options) {
    if (options === void 0) { options = {}; }
    var _a = options.filter, filter = _a === void 0 ? function () { return true; } : _a, waitWindowMs = DEFAULT_WAIT_WINDOW_MILLIS, quietWindowMs = DEFAULT_QUIET_WINDOW_MILLIS; // options
    var entries = (0, performanceEntries_1.performanceEntries)(quietWindowMs);
    // If performance API is not available, capture route changes without performance metrics
    if (!entries) {
        log_1.log.warn('Performance API is not supported. Route change events will be collected without timing values.');
        return (0, onRouteChange_1.onRouteChange)(function (routeChangeEntry) {
            if (filter(routeChangeEntry))
                callback(routeChangeEntry);
        });
    }
    var lastEndTime = 0;
    // eslint-disable-next-line compat/compat
    function calculateRouteChangeTimes(timestamp) {
        if (timestamp === void 0) { timestamp = performance.now(); }
        var block; // eslint-disable-next-line no-cond-assign
        while (block = entries.popBlock(timestamp)) {
            var routeChangeEntries = block.block.filter(function (entry) { return entry.entryType === ROUTE_CHANGE_ENTRY_NAME; });
            // Multiple routeChange entries in the same block, are considered a single routeChange
            if (routeChangeEntries.length) {
                var startTime = block.block[0].startTime;
                var duration = block.endTime - startTime;
                // @TODO consider emitting a `timeOnRoute` event besides a `routeChange` event
                callback((0, assign_1.objectAssign)(routeChangeEntries[0], {
                    startTime: startTime,
                    duration: duration,
                    fromUrl: routeChangeEntries[0].fromUrl,
                    toUrl: routeChangeEntries[routeChangeEntries.length - 1].toUrl,
                    timeOnRoute: startTime - lastEndTime,
                }));
                lastEndTime = block.endTime;
            }
        }
    }
    var timerId;
    function routeChangeListener(routeChangeEntry) {
        if (!filter(routeChangeEntry))
            return;
        (0, assign_1.objectAssign)(routeChangeEntry, {
            entryType: ROUTE_CHANGE_ENTRY_NAME,
            startTime: performance.now(),
            duration: 0,
        });
        entries.addEntry(routeChangeEntry);
        // Wait for calculating navigation times, because there might be pending resource entries due to in-flight requests
        clearTimeout(timerId);
        timerId = setTimeout(calculateRouteChangeTimes, waitWindowMs);
    }
    var routeChangeObserver = (0, onRouteChange_1.onRouteChange)(routeChangeListener);
    return {
        // Process pending entries
        flush: function () {
            // Passing no timestamp (false), in order to pop all blocks
            calculateRouteChangeTimes(false);
        },
        // Cleanup resources and process pending entries
        disconnect: function () {
            entries.disconnect();
            routeChangeObserver.disconnect();
            clearTimeout(timerId);
            calculateRouteChangeTimes(false);
        }
    };
}
exports.onRouteChangeTiming = onRouteChangeTiming;
