import { setSchedule, flush, track, queue } from './queue';
import { isArray } from './isArray';
import { isBoolean } from './isBoolean';
import { isObject } from './isObject';
import { isString } from './isString';
import { log } from './log';
import { whenLoaded, onPageHideOrVisibilityChange } from './whenLoaded';
import { objectAssign } from './assign';
import { validateIdentity, areEqual } from './validateIdentity';
import { CONSENT_DECLINED, CONSENT_GRANTED } from './constants';
// Built-in event collectors
import { handleCustomErrors, onError } from '../metrics/errors';
import { onNavigationTimingMetrics } from '../metrics/navigation';
import { validateProperties } from './validateEvent';
// Browser support:
// - ES5 syntax
// - assumes availability of `window.addEventListener` and `document.location`, which are broadly supported.
// - feature detection of Promise, History and Performance APIs is done by event collector modules. These features are required for some modules to collect data, but not for the RUM Agent to work.
// In Browser, we pollute the global `window` object with the agent.
// In NodeJS, we only export it and no event collectors are registered.
var isBrowser = typeof window === 'object' && typeof document === 'object';
var globalRef = isBrowser ? window : {};
(function (w, isBrowser) {
    if (w.SplitRumAgent)
        return;
    var _config = {
        i: [],
        a: false,
        p: {},
        prefix: '',
        url: 'https://events.split.io/api',
        pushRate: 30,
        queueSize: 5000,
        log: log,
        userConsent: CONSENT_GRANTED // User consent is assumed to be granted by default
    };
    var _isConfigured = false;
    function calculateAndFlush() {
        if (isBrowser && !_isConfigured && _config.a && _config.i.length) {
            _isConfigured = true;
            // always async never inasync ;)
            setTimeout(flush, 0);
        }
    }
    var collectors = [];
    // SplitRumAgent would be our namespace
    var SplitRumAgent = {
        // Initialization params
        setup: function (sdkKey, config) {
            if (isObject(config)) {
                objectAssign(_config, config);
            }
            if (isString(sdkKey)) {
                _config.a = sdkKey;
                calculateAndFlush();
            }
            else {
                _config.log.error('SDK key must be a string.');
            }
            // allow for chaining.
            return SplitRumAgent;
        },
        // Configure identities
        addIdentities: function (identities) {
            if (isArray(identities)) {
                identities.forEach(function (identity) { return SplitRumAgent.addIdentity(identity); });
            }
            else {
                _config.log.error('Identities must be an array of objects with key and trafficType.');
            }
        },
        addIdentity: function (identity) {
            var validatedIdentity = validateIdentity(identity, _config.log);
            if (validatedIdentity && !_config.i.some(function (i) { return areEqual(i, validatedIdentity); })) {
                _config.i.push(validatedIdentity);
                calculateAndFlush();
            }
        },
        removeIdentities: function () {
            _config.i = [];
        },
        removeIdentity: function (identity) {
            var validatedIdentity = validateIdentity(identity, _config.log);
            if (validatedIdentity) {
                _config.i = _config.i.filter(function (i) { return !areEqual(i, validatedIdentity); });
            }
        },
        getIdentities: function () {
            return _config.i;
        },
        // Custom error handler.
        trackError: function (e) {
            return handleCustomErrors(e, SplitRumAgent);
        },
        // Track custom events.
        track: track,
        // register event collector
        register: function (eventCollector) {
            if (typeof eventCollector !== 'function') {
                _config.log.error('register method must be called with an event collector function.');
            }
            else {
                collectors.push(eventCollector(SplitRumAgent));
            }
            // allow for chaining.
            return SplitRumAgent;
        },
        // Custom properties
        setProperties: function (properties) {
            objectAssign(_config.p, validateProperties(properties, _config.log));
        },
        getProperties: function () {
            return _config.p;
        },
        removeProperties: function () {
            _config.p = {};
        },
        // User consent
        setUserConsent: function (userConsent) {
            if (!isBoolean(userConsent)) {
                _config.log.warn('setUserConsent: provided param must be a boolean value');
                return false;
            }
            _config.userConsent = userConsent ? CONSENT_GRANTED : CONSENT_DECLINED;
            return true;
        },
        getUserConsent: function () {
            return _config.userConsent;
        },
        // Private members for internal use only.
        // @TODO review how to expose config
        __getConfig: function () {
            return _config;
        },
        __queue: queue,
    };
    if (isBrowser) {
        // Built-in collectors
        SplitRumAgent.register(onNavigationTimingMetrics);
        SplitRumAgent.register(onError);
        // Post events periodically
        whenLoaded(setSchedule);
        // If there's a pagehide or visibilitychange event, calculate what's possible and send events using beacon by default
        onPageHideOrVisibilityChange(function () {
            collectors.forEach(function (collector) {
                if (collector && typeof collector.flush === 'function')
                    collector.flush();
            });
            flush(true);
        });
    }
    w.SplitRumAgent = SplitRumAgent;
})(globalRef, isBrowser);
export var SplitRumAgent = globalRef.SplitRumAgent;
