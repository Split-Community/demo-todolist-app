import { getConnectionType, getUrl, userAgent } from './context';
import { sendEvents } from './transport';
import { isObject } from './isObject';
import { assignIdentities, objectAssign } from './assign';
import { CONSENT_DECLINED, CONSENT_GRANTED } from './constants';
import { validateEvent } from './validateEvent';
// How to detect we are configured? Static = may be present by now
//                                  Delayed = that would be the trigger but need to notify here.
// We could start it from a different spot calling setSchedule;
// We'll treat it as a FIFO queue
// Size/batch limitations => TODO only if necessary.
export var queue = [];
// @TODO: Apply batching if needed
/**
 * Flush the queue of events.
 *
 * @param useBeacon - Whether to use navigator.sendBeacon or not. Defaults to false.
 * @returns true if events were sent, or a falsy value otherwise (e.g., queue is empty, config is not ready, or there was an error sending events)
 */
export function flush(useBeacon) {
    var conf = window.SplitRumAgent.__getConfig();
    // Only send events if we do have the config.
    if (conf.a && conf.i.length && conf.userConsent === CONSENT_GRANTED) {
        var toSend = queue.splice(0, queue.length);
        return toSend.length && sendEvents(toSend, useBeacon);
    }
}
export function setSchedule() {
    setInterval(flush, window.SplitRumAgent.__getConfig().pushRate * 1000);
    flush(); // Attempt a flush when setting the schedule, like a first tick.
}
export function track(eventTypeId, value, properties) {
    var conf = window.SplitRumAgent.__getConfig();
    var eventData = validateEvent(isObject(eventTypeId) ?
        eventTypeId : {
        eventTypeId: eventTypeId,
        value: value,
        properties: properties
    }, conf.log);
    // If the event is invalid or the user consent is DECLINED, drop the event.
    if (!eventData || conf.userConsent === CONSENT_DECLINED)
        return false;
    // If people configures the agent at a really late time, prevent having a giant queue and attempt to send them or drop. First events will be the most important ones anyways.
    if (queue.length >= conf.queueSize) {
        if (!flush()) {
            conf.log.warn('Dropping event due to queue size limit.');
            return false;
        }
    }
    // @ts-expect-error adding timestamp to event
    eventData.timestamp = Date.now(); // <-- This is not the most accurate but it shouldn't really matter much. The error margin should be small. We can actually calculate the timestamp later.
    if (conf.prefix)
        eventData.eventTypeId = conf.prefix + "." + eventData.eventTypeId;
    // include extra properties
    var commonProperties = {
        connectionType: getConnectionType(),
        url: getUrl(),
        userAgent: userAgent
    };
    // merge common properties with custom and event properties
    eventData.properties = objectAssign(commonProperties, conf.p, isObject(eventData.properties) ? eventData.properties : {});
    // @ts-expect-error not part of the public API
    if (window.SplitRumAgent.onEvent)
        eventData = window.SplitRumAgent.onEvent(eventData);
    if (eventData)
        assignIdentities(eventData, window.SplitRumAgent.__getConfig().i, queue);
    return true;
}
