import { assignIdentities } from './assign';
import { languageVersion } from './context';
// Key and trafficType are pieces of data we'll add here because:
// a) not having those should not prevent queueing,
// b) we may have multiple tt/key tuples, may be easier to handle here.
export function sendEvents(events, useBeacon) {
    var config = window.SplitRumAgent.__getConfig();
    var eventsWithIdentity = [];
    for (var i = 0; i < events.length; i++) {
        var event_1 = events[i];
        assignIdentities(event_1, config.i, eventsWithIdentity);
    }
    if (eventsWithIdentity.length) {
        return post(config.url + '/events/beacon', {
            entries: eventsWithIdentity,
            token: config.a,
            sdk: languageVersion
        }, useBeacon);
    }
    return false;
}
// Post data to our BE. Exporting only for UT purposes.
export function post(url, data, useBeacon) {
    var stringifiedData = JSON.stringify(data);
    useBeacon = useBeacon // check we don't avoid on purpose
        && typeof navigator === 'object' && navigator.sendBeacon; // and that it exists
    return useBeacon ?
        navigator.sendBeacon(url, stringifiedData) :
        fallbackPost(url, stringifiedData);
}
// Fetch and XHR request fallback. Exporting only for UT purposes.
export function fallbackPost(url, payload) {
    if (typeof fetch === 'function') {
        fetch(url, {
            method: 'POST',
            body: payload,
            headers: {
                'Content-Type': 'text/plain;charset=UTF-8'
            }
        }).catch(function () {
            // noop
        });
    }
    else {
        try {
            var req = new XMLHttpRequest();
            req.open('POST', url, true);
            req.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8');
            req.send(payload);
        }
        catch (e) {
            return false;
        }
    }
    return true; // This is a fallback so it's mostly fire and forget.
}
