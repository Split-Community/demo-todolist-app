import { getRoute } from '../../utils/context';
/**
 * Listens for History API method calls and events, and calls the `callback` function each time a route change is detected.
 * @param callback function to call when a route change is detected
 */
export function onRouteChange(callback) {
    var fromUrl = getRoute();
    function handleRouteChange(historyChangeSource) {
        var toUrl = getRoute();
        if (toUrl !== fromUrl) {
            var routeChange_1 = { historyChangeSource: historyChangeSource, fromUrl: fromUrl, toUrl: toUrl };
            // Async call to ensure that app logic responding to the URL change is executed first
            setTimeout(function () { return callback(routeChange_1); });
            fromUrl = toUrl;
        }
    }
    // If History API is available, spy `pushState` and `replaceState` methods for URL changes.
    // No need to spy `go`, `back` and `forward` History methods, because they trigger `popstate` events
    if (window.history) {
        ['pushState', 'replaceState'].forEach(function (method) {
            if (typeof history[method] === 'function') {
                var originalMethod_1 = history[method];
                Object.defineProperty(history, method, {
                    value: function () {
                        var result = originalMethod_1.apply(this, arguments);
                        handleRouteChange(method);
                        return result;
                    },
                    writable: true, configurable: true // to let other libraries spy history methods
                });
            }
        });
    }
    // Listen `popstate` events, emitted when using `location` API (https://html.spec.whatwg.org/multipage/nav-history-apis.html#the-location-interface),
    // or traversing the history stack by using `go`, `back` and `forward` history methods or browser navigation buttons.
    // It isn't emitted when calling `pushState` and `replaceState` history methods, because they don't constitute a navigation or history traversal.
    // No need to spy `hashchange` events, because they are emitted with `popstate`.
    var handlePopstate = function () { return handleRouteChange('popstate'); };
    window.addEventListener('popstate', handlePopstate);
    return {
        flush: function () { },
        // Stop callback from receiving new entries
        disconnect: function () {
            window.removeEventListener('popstate', handlePopstate);
            callback = function () { }; // replace user callback, instead of restoring history methods
        }
    };
}
