import { objectAssign } from '../../utils/assign';
var ENTRY_TYPES = ['resource', 'longtask'];
export function performanceEntries(quietWindowMs) {
    // Check that required Performance APIs are available
    if (typeof window === 'undefined' || !window.performance || !window.performance.getEntries || !window.PerformanceObserver)
        return;
    // eslint-disable-next-line compat/compat
    var entries = performance.getEntries().filter(function (entry) { return ENTRY_TYPES.includes(entry.entryType); });
    function addEntry(entry) {
        entries.push(entry);
        // Sort by startTime, because entries are emitted in "end time" order (entry.startTime + entry.duration)
        entries.sort(function (a, b) { return a.startTime - b.startTime; });
    }
    // Catch errors since some browsers throw when using the new `type` option.
    // https://bugs.webkit.org/show_bug.cgi?id=209216
    var po;
    try {
        po = new PerformanceObserver(function (list) {
            list.getEntries().forEach(addEntry);
        });
        po.observe({ entryTypes: ENTRY_TYPES });
    }
    catch (e) {
        // Return undefined if performance API is not available
        return;
    }
    /**
     * Extracts the next block of entries, a subarray delimited by a quiet window
     * @param {false|number} timestamp
     */
    function popBlock(timestamp) {
        if (entries.length === 0)
            return;
        var endIndex = 0;
        var endTime = entries[endIndex].startTime + entries[endIndex].duration;
        while (endIndex < entries.length - 1 &&
            endTime + quietWindowMs >= entries[endIndex + 1].startTime) {
            endIndex++;
            endTime = Math.max(endTime, entries[endIndex].startTime + entries[endIndex].duration);
        }
        // If a timestamp was provided, and the end of entries array was reached, and the block ending timestamp is within the QUIET WINDOW,
        // we don't extract the block to wait for possible pending entries
        if (timestamp && endIndex === entries.length - 1 && endTime + quietWindowMs >= timestamp)
            return;
        return {
            block: entries.splice(0, endIndex + 1),
            endTime: endTime
        };
    }
    return objectAssign(entries, {
        addEntry: addEntry,
        popBlock: popBlock,
        disconnect: function () {
            po.disconnect();
        }
    });
}
