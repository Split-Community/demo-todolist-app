import { getErrorData } from '../utils/getErrorData';
import { UNAVAILABLE } from '../utils/constants';
/**
 * Add error into queue
 */
function trackError(error, ctx) {
    var errorData = getErrorData(error);
    return errorData ?
        ctx.track({
            eventTypeId: 'error',
            value: null,
            properties: {
                message: errorData.message,
                stack: errorData.stack,
            }
        }) :
        false;
}
/**
 * Handle custom error. Here we handle whatever the customer want to send. Ideally
 * we expect a string or an error object.
 */
export function handleCustomErrors(e, ctx) {
    return trackError(e ? e : UNAVAILABLE, ctx);
}
/**
 * Captures uncaught errors and promise rejections.
 *
 * @TODO: sync snippet in HTML head to not miss events if loaded asynchronously.
 */
export function onError(ctx) {
    function handleUncaughtErrors(event) {
        trackError(event ? event.error || event.message || UNAVAILABLE : UNAVAILABLE, ctx);
    }
    function handleRejectionsErrors(e) {
        trackError(e ? e.reason : UNAVAILABLE, ctx);
    }
    // In case customer placed the snippet in the head, remove listeners and process errors
    var w = window; // @ts-expect-error object might be polluted
    var g = w.__error;
    if (g) {
        w.removeEventListener('error', g.l1);
        w.removeEventListener('unhandledrejection', g.l2);
        // @TODO remove `setTimeout` eventually. ATM we have to run next code asynchronously, because `track` calls require global SplitRumAgent available
        setTimeout(function () {
            g.e1.forEach(handleUncaughtErrors);
            g.e2.forEach(handleRejectionsErrors); // @ts-expect-error object might be polluted
            delete w.__error;
        }, 0);
    }
    // Capture browser uncaught errors.
    w.addEventListener('error', handleUncaughtErrors);
    // Capture browser promise rejection errors.
    w.addEventListener('unhandledrejection', handleRejectionsErrors);
}
