"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SplitSuite = void 0;
var objectAssign_1 = require("@splitsoftware/splitio-commons/cjs/utils/lang/objectAssign");
var sets_1 = require("@splitsoftware/splitio-commons/cjs/utils/lang/sets");
var constants_1 = require("@splitsoftware/splitio-commons/cjs/utils/constants");
var browser_rum_agent_1 = require("@splitsoftware/browser-rum-agent");
var full_1 = require("@splitsoftware/splitio-browserjs/full");
var DEFAULT_TRAFFIC_TYPE = 'user';
// @TODO remove eventually when RUM Agent registers web vitals by default
var registerWebVitals = true;
/**
 * Split Suite for Browsers.
 *
 * @param config configuration object used to instantiate the Suite
 * @param __updateModules optional function that lets redefine internal SDK modules. Use with
 * caution since, unlike `config`, this param is not validated neither considered part of the public API.
 * @throws Will throw an error if the provided config is invalid.
 */
function SplitSuite(config, __updateModules) {
    // @ts-expect-error passing a non-public param
    var sdk = (0, full_1.SplitFactory)(config, __updateModules);
    var settings = sdk.settings;
    var clients = new sets_1._Set();
    // Override UserConsent.setStatus to update RUM Agent consent
    var originalSetStatus = sdk.UserConsent.setStatus;
    sdk.UserConsent.setStatus = function (newStatus) {
        browser_rum_agent_1.SplitRumAgent.setUserConsent(newStatus);
        return originalSetStatus.apply(this, arguments);
    };
    // Create Suite instance extending SDK
    var suite = (0, objectAssign_1.objectAssign)({}, sdk, {
        client: function () {
            var client = sdk.client.apply(sdk, arguments);
            if (!clients.has(client)) {
                clients.add(client);
                var identity_1 = {
                    key: client.key,
                    // For main client, use trafficType from settings. For shared clients, use second argument. If not provided, use default.
                    trafficType: (arguments[0] ? arguments[1] : settings.core.trafficType) || DEFAULT_TRAFFIC_TYPE
                };
                browser_rum_agent_1.SplitRumAgent.addIdentity(identity_1);
                // override client.destroy to remove identity from RUM Agent
                var originalDestroy_1 = client.destroy;
                client.destroy = function () {
                    browser_rum_agent_1.SplitRumAgent.removeIdentity(identity_1);
                    return originalDestroy_1.apply(client, arguments);
                };
            }
            return client;
        },
        rumAgent: function () {
            return browser_rum_agent_1.SplitRumAgent;
        },
        destroy: function () {
            return Promise.all((0, sets_1.setToArray)(clients).map(function (client) { return client.destroy(); }));
        }
    });
    // Setup the RUM Agent only in standalone mode
    if (settings.mode === constants_1.STANDALONE_MODE) {
        if (registerWebVitals) {
            browser_rum_agent_1.SplitRumAgent.register((0, browser_rum_agent_1.webVitals)());
            registerWebVitals = false;
        }
        var agentConfig = browser_rum_agent_1.SplitRumAgent.__getConfig();
        if (agentConfig.a && agentConfig.a !== settings.core.authorizationKey) {
            settings.log.warn('RUM Agent already setup. The new Suite instance will reset the RUM Agent configuration.');
            browser_rum_agent_1.SplitRumAgent.removeIdentities(); // reset identities for new SDK key
        }
        agentConfig.log = settings.log;
        browser_rum_agent_1.SplitRumAgent.setup(settings.core.authorizationKey, (0, objectAssign_1.objectAssign)({
            url: settings.urls.events,
            userConsent: settings.userConsent
        }, settings.rumAgent));
    }
    return suite;
}
exports.SplitSuite = SplitSuite;
