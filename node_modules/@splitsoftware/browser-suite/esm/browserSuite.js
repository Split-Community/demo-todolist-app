import { objectAssign } from '@splitsoftware/splitio-commons/esm/utils/lang/objectAssign';
import { _Set, setToArray } from '@splitsoftware/splitio-commons/esm/utils/lang/sets';
import { STANDALONE_MODE } from '@splitsoftware/splitio-commons/esm/utils/constants';
import { SplitRumAgent, webVitals } from '@splitsoftware/browser-rum-agent';
import { SplitFactory } from '@splitsoftware/splitio-browserjs/full';
var DEFAULT_TRAFFIC_TYPE = 'user';
// @TODO remove eventually when RUM Agent registers web vitals by default
var registerWebVitals = true;
/**
 * Split Suite for Browsers.
 *
 * @param config configuration object used to instantiate the Suite
 * @param __updateModules optional function that lets redefine internal SDK modules. Use with
 * caution since, unlike `config`, this param is not validated neither considered part of the public API.
 * @throws Will throw an error if the provided config is invalid.
 */
export function SplitSuite(config, __updateModules) {
    // @ts-expect-error passing a non-public param
    var sdk = SplitFactory(config, __updateModules);
    var settings = sdk.settings;
    var clients = new _Set();
    // Override UserConsent.setStatus to update RUM Agent consent
    var originalSetStatus = sdk.UserConsent.setStatus;
    sdk.UserConsent.setStatus = function (newStatus) {
        SplitRumAgent.setUserConsent(newStatus);
        return originalSetStatus.apply(this, arguments);
    };
    // Create Suite instance extending SDK
    var suite = objectAssign({}, sdk, {
        client: function () {
            var client = sdk.client.apply(sdk, arguments);
            if (!clients.has(client)) {
                clients.add(client);
                var identity_1 = {
                    key: client.key,
                    // For main client, use trafficType from settings. For shared clients, use second argument. If not provided, use default.
                    trafficType: (arguments[0] ? arguments[1] : settings.core.trafficType) || DEFAULT_TRAFFIC_TYPE
                };
                SplitRumAgent.addIdentity(identity_1);
                // override client.destroy to remove identity from RUM Agent
                var originalDestroy_1 = client.destroy;
                client.destroy = function () {
                    SplitRumAgent.removeIdentity(identity_1);
                    return originalDestroy_1.apply(client, arguments);
                };
            }
            return client;
        },
        rumAgent: function () {
            return SplitRumAgent;
        },
        destroy: function () {
            return Promise.all(setToArray(clients).map(function (client) { return client.destroy(); }));
        }
    });
    // Setup the RUM Agent only in standalone mode
    if (settings.mode === STANDALONE_MODE) {
        if (registerWebVitals) {
            SplitRumAgent.register(webVitals());
            registerWebVitals = false;
        }
        var agentConfig = SplitRumAgent.__getConfig();
        if (agentConfig.a && agentConfig.a !== settings.core.authorizationKey) {
            settings.log.warn('RUM Agent already setup. The new Suite instance will reset the RUM Agent configuration.');
            SplitRumAgent.removeIdentities(); // reset identities for new SDK key
        }
        agentConfig.log = settings.log;
        SplitRumAgent.setup(settings.core.authorizationKey, objectAssign({
            url: settings.urls.events,
            userConsent: settings.userConsent
        }, settings.rumAgent));
    }
    return suite;
}
